#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

enum {
    TS_STATUS_OK,
    TS_STATUS_INVALID_PTR,
    TS_STATUS_COMPILE_ERROR
};
typedef uint8_t ts_status_t;

enum {
    TS_OPTION_CAPTURE_TOKENS              = 1 << 0,
    TS_OPTION_TSX                         = 1 << 1,
    TS_OPTION_DECORATORS                  = 1 << 2,
    TS_OPTION_DTS                         = 1 << 3,
    TS_OPTION_NO_EARLY_ERRORS             = 1 << 4,
    TS_OPTION_DISALLOW_AMBIGUOUS_JSX_LIKE = 1 << 5,
    TS_OPTION_SCOPE_ANALYSIS              = 1 << 6,

    TS_OPTION_NONE = 0,
    TS_OPTION_DEFAULT = TS_OPTION_CAPTURE_TOKENS | TS_OPTION_DECORATORS | TS_OPTION_NO_EARLY_ERRORS | TS_OPTION_SCOPE_ANALYSIS,
};
typedef uint8_t ts_options_t;

/// module_or_error points to a buffer of size module_or_error_len. It is not NULL-terminated.
/// When the result is TS_STATUS_COMPILE_ERROR, module_or_error will be the error message.
/// When the result is TS_STATUS_OK, module_or_error will be the transpiled code
/// When the result is TS_STATUS_INVALID_PTR, module_or_error will be left unchanged.
/// The caller is responsible for freeing the buffer with ts_compile_free. Using anything else to free it is undefined behavior.
ts_status_t ts_compile(char const *input, size_t input_len, char const *filename, size_t filename_len, ts_options_t options, char const **module_or_error, size_t *module_or_error_len);

/// Frees the buffer generated by ts_compile.
void ts_compile_free(char const *module_or_error, size_t module_or_error_len);

#ifdef __cplusplus
}
#endif
